#!/usr/bin/env node

const fs         = require("fs");
const marked     = require("marked");
const _          = require("lodash");
const makeConfig = require("../lib/config.js");
const {
  parseAct,
  caseSplitAct,
  newCleanup,
  makeInterabiExhaustiveness
}                = require("../lib/build.js");
const {
  read,
  revert,
  testPath,
}                = require("../lib/util.js");

const __a2n = act => act.subject + "_" + act.name;

const KLAB_OUT = process.env.KLAB_OUT || "out";

const usage = `
Usage:
  klab make
`

if (!testPath("./config.json")) {revert("No config.json file in directory. Review `klab/examples` folder for inspiration")}
const config_json   = JSON.parse(fs.readFileSync("./config.json"));
const config        = makeConfig(config_json);
const config_path   = config.src.specification;
const raw_md_config = Array.isArray(config_path) && config_path.map(p => read(p)).join("\n\n") || read(config_path)

const tokens        = marked.lexer(raw_md_config)
const parsed_tokens = tokens
  .map(t => {
    if(t.type == 'code' && t.lang === "act") {
      const parsedAct = parseAct(config)(t.text, true);
      const cases = caseSplitAct(config)(parsedAct);
      return {
        type: 'code',
        lang: "act",
        obj: parsedAct,
        cases: cases,
        text: newCleanup(parsedAct, t.text)
      };
    } else {
      return t;
    }
  });

const act_collection = parsed_tokens
  .filter(e => e.type === "code" && e.lang == "act")
  .map(e => e.cases)
  .reduce((a, cs) => a.concat(cs), [])

var exhaustiveness = new Set()
for (var act_num in act_collection) {
  exhaustiveness.add(act_collection[act_num].act.subject + '__exhaustiveness.prove')
}

const dependencies = Object.assign({},
  ...act_collection
  .map((a) => ({ [a.name]: (a.act.calls || []).map(d => d.replace('.', '_') + '_pass') })))

output_makefile = []
top_level = [...exhaustiveness]
for (var dep_name in dependencies) {
  let dep_name_without_rough = dep_name.substring(0, dep_name.length - 6)
  let dep_subtargets         = dependencies[dep_name]
  let isPass                 = dep_name.endsWith('_pass_rough')
  let target_string    = isPass ? 'prove-dump' : 'prove'
  let subtarget_string = dep_subtargets.map(d => d + '.prove').join(' ')
  let prove_string     = isPass ? 'PROVE_DUMP' : 'PROVE'
  output_makefile.push(dep_name + '.' + target_string + ': ' + dep_name + '.build')
  output_makefile.push('\t$(' + prove_string + ') ' + dep_name)
  output_makefile.push('')
  output_makefile.push(dep_name + '.build: mkdirs ' + subtarget_string)
  output_makefile.push('\t$(BUILD) ' + dep_name)
  output_makefile.push('')
  top_level.push((isPass ? dep_name_without_rough : dep_name) + '.prove')
}
output_makefile.push('mkdirs:')
output_makefile.push('\t@mkdir -p $(OUT_DIR)/specs')
output_makefile.push('\t@mkdir -p $(OUT_DIR)/acts')
output_makefile.push('\t@mkdir -p $(OUT_DIR)/gas')
output_makefile.push('\t@mkdir -p $(OUT_DIR)/meta/name')
output_makefile.push('\t@mkdir -p $(OUT_DIR)/meta/data')
output_makefile.push('\t@mkdir -p $(OUT_DIR)/output')
output_makefile.push('\t@mkdir -p $(CURDIR)/specs')
output_makefile.push('')
output_makefile.push('%_pass.prove: %_pass.build')
output_makefile.push('\t$(PROVE) $*_pass')
output_makefile.push('')
output_makefile.push('%_pass.build: mkdirs %_pass_rough.prove-dump')
output_makefile.push('\t$(GET_GAS) $*_pass_rough')
output_makefile.push('\t$(SOLVE_GAS) $*_pass_rough')
output_makefile.push('\t$(BUILD) $*_pass')
output_makefile.push('')
output_makefile.push('%__exhaustiveness.prove: %__exhaustiveness.build')
output_makefile.push('\t$(PROVE) $*__exhaustiveness')
output_makefile.push('')
output_makefile.push('%__exhaustiveness.build: mkdirs')
output_makefile.push('\t$(BUILD) $*__exhaustiveness')
output_makefile.push('')
output_makefile.push('prove: ' + top_level.join(' \\\n       '))
output_makefile.push('')

console.log(output_makefile.join('\n'))
